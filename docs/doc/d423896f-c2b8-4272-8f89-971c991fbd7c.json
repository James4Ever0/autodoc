{
    "summary": "HNSWLib, a SaveableVectorStore extension, initializes index, embeddings, and docstore. It creates an HNSW index for texts and embeddings, adds vectors/documents, performs search with query vector, and handles errors while supporting saving/loading of indexes and adding new documents.",
    "details": [
        {
            "comment": "This code defines a class called `HNSWLib` that extends the `SaveableVectorStore` class. It takes in an embeddings object and a set of arguments (`args`) that include optional parameters such as docstore and index from the `HNSWLibBase` interface. The constructor initializes the index and docstore properties based on the provided args, sets the embeddings property to the given embeddings object, and initializes an InMemoryDocstore if none is provided in the args. The `addDocuments` method adds a list of documents to the store by mapping their page contents into an array.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":0-37",
            "content": "import fs from 'node:fs/promises';\nimport path from 'node:path';\nimport HierarchicalNSW from 'hnswlib-node';\nimport type {\n  HierarchicalNSW as HierarchicalNSWT,\n  SpaceName,\n} from 'hnswlib-node';\nimport { Document, InMemoryDocstore } from 'langchain/docstore';\nimport { Embeddings } from 'langchain/embeddings';\nimport { SaveableVectorStore } from 'langchain/vectorstores';\nexport interface HNSWLibBase {\n  space: SpaceName;\n  numDimensions?: number;\n}\nexport interface HNSWLibArgs extends HNSWLibBase {\n  docstore?: InMemoryDocstore;\n  index?: HierarchicalNSWT;\n}\nexport class HNSWLib extends SaveableVectorStore {\n  _index?: HierarchicalNSWT;\n  docstore: InMemoryDocstore;\n  args: HNSWLibBase;\n  constructor(embeddings: Embeddings, args: HNSWLibArgs) {\n    super(embeddings, args);\n    this._index = args.index;\n    this.args = args;\n    this.embeddings = embeddings;\n    this.docstore = args?.docstore ?? new InMemoryDocstore();\n  }\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);"
        },
        {
            "comment": "The code initializes and returns an HNSW index based on the provided texts and embeddings. It ensures that the space and numDimensions arguments are defined, and if not, it throws an error. The index is initialized by adding the vectors to the HNSW library using the addVectors method, and checks if the index is already initialized. If not, it calls getHierarchicalNSW with the provided arguments to create a new instance of HierarchicalNSW, and initializes the index with the number of vectors passed in.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":38-71",
            "content": "    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n    );\n  }\n  private static async getHierarchicalNSW(args: HNSWLibBase) {\n    const { HierarchicalNSW } = await HNSWLib.imports();\n    if (!args.space) {\n      throw new Error('hnswlib-node requires a space argument');\n    }\n    if (args.numDimensions === undefined) {\n      throw new Error('hnswlib-node requires a numDimensions argument');\n    }\n    return new HierarchicalNSW(args.space, args.numDimensions);\n  }\n  private async initIndex(vectors: number[][]) {\n    if (!this._index) {\n      if (this.args.numDimensions === undefined) {\n        this.args.numDimensions = vectors[0].length;\n      }\n      this.index = await HNSWLib.getHierarchicalNSW(this.args);\n    }\n    if (!this.index.getCurrentCount()) {\n      this.index.initIndex(vectors.length);\n    }\n  }\n  public get index(): HierarchicalNSWT {\n    if (!this._index) {\n      throw new Error(\n        'Vector store not initialised yet. Try calling `addTexts` first.',\n      );"
        },
        {
            "comment": "This function adds vectors and documents to the HNSW index, initializing it if necessary. It checks for correct vector and document lengths before resizing the index if needed. The comments suggest adding normalization support in the future and throw errors if lengths don't match or dimensions are incorrect.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":72-101",
            "content": "    }\n    return this._index;\n  }\n  private set index(index: HierarchicalNSWT) {\n    this._index = index;\n  }\n  async addVectors(vectors: number[][], documents: Document[]) {\n    if (vectors.length === 0) {\n      return;\n    }\n    await this.initIndex(vectors);\n    // TODO here we could optionally normalise the vectors to unit length\n    // so that dot product is equivalent to cosine similarity, like this\n    // https://github.com/nmslib/hnswlib/issues/384#issuecomment-1155737730\n    // While we only support OpenAI embeddings this isn't necessary\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and metadatas must have the same length`);\n    }\n    if (vectors[0].length !== this.args.numDimensions) {\n      throw new Error(\n        `Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`,\n      );\n    }\n    const capacity = this.index.getMaxElements();\n    const needed = this.index.getCurrentCount() + vectors.length;\n    if (needed > capacity) {\n      this.index.resizeIndex(needed);"
        },
        {
            "comment": "This code adds vectors and their corresponding documents to the index and docstore, and performs a similarity search on the index using the provided query vector. It checks for errors in the query length and k value before executing the search, and returns an array of document-distance pairs as the result.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":102-130",
            "content": "    }\n    const docstoreSize = this.docstore.count;\n    for (let i = 0; i < vectors.length; i += 1) {\n      this.index.addPoint(vectors[i], docstoreSize + i);\n      this.docstore.add({ [docstoreSize + i]: documents[i] });\n    }\n  }\n  async similaritySearchVectorWithScore(query: number[], k: number) {\n    if (query.length !== this.args.numDimensions) {\n      throw new Error(\n        `Query vector must have the same length as the number of dimensions (${this.args.numDimensions})`,\n      );\n    }\n    if (k > this.index.getCurrentCount()) {\n      const total = this.index.getCurrentCount();\n      console.warn(\n        `k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`,\n      );\n      // eslint-disable-next-line no-param-reassign\n      k = total;\n    }\n    const result = this.index.searchKnn(query, k);\n    return result.neighbors.map(\n      (docIndex, resultIndex) =>\n        [\n          this.docstore.search(String(docIndex)),\n          result.distances[resultIndex],\n        ] as [Document, number],"
        },
        {
            "comment": "The code above contains methods for saving and loading an instance of HNSWLib. The `save` method creates a directory, writes the index, args, and docstore to separate JSON files within that directory. The `load` method reads the index and docstore from their respective JSON files and returns a new HNSWLib instance with the provided embeddings.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":131-164",
            "content": "    );\n  }\n  async save(directory: string) {\n    await fs.mkdir(directory, { recursive: true });\n    await Promise.all([\n      this.index.writeIndex(path.join(directory, 'hnswlib.index')),\n      await fs.writeFile(\n        path.join(directory, 'args.json'),\n        JSON.stringify(this.args),\n      ),\n      await fs.writeFile(\n        path.join(directory, 'docstore.json'),\n        JSON.stringify(Array.from(this.docstore._docs.entries())),\n      ),\n    ]);\n  }\n  static async load(directory: string, embeddings: Embeddings) {\n    const args = JSON.parse(\n      await fs.readFile(path.join(directory, 'args.json'), 'utf8'),\n    );\n    const index = await HNSWLib.getHierarchicalNSW(args);\n    const [docstoreFiles] = await Promise.all([\n      fs\n        .readFile(path.join(directory, 'docstore.json'), 'utf8')\n        .then(JSON.parse),\n      index.readIndex(path.join(directory, 'hnswlib.index')),\n    ]);\n    args.docstore = new InMemoryDocstore(new Map(docstoreFiles));\n    args.index = index;\n    return new HNSWLib(embeddings, args);"
        },
        {
            "comment": "The code defines a class HNSWLib that has methods for creating a Hierarchical Navigable Small World (HNSW) index from texts or existing documents, and importing the required library. The class uses embeddings for indexing and provides methods to add new documents to the index.",
            "location": "\"/media/root/Prima/works/autodoc/docs/src/src/langchain/hnswlib.ts\":165-207",
            "content": "  }\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[],\n    embeddings: Embeddings,\n    dbConfig?: {\n      docstore?: InMemoryDocstore;\n    },\n  ): Promise<HNSWLib> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata: metadatas[i],\n      });\n      docs.push(newDoc);\n    }\n    return HNSWLib.fromDocuments(docs, embeddings, dbConfig);\n  }\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: Embeddings,\n    dbConfig?: {\n      docstore?: InMemoryDocstore;\n    },\n  ): Promise<HNSWLib> {\n    const args: HNSWLibArgs = {\n      docstore: dbConfig?.docstore,\n      space: 'cosine',\n    };\n    const instance = new this(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n  static async imports(): Promise<{\n    HierarchicalNSW: typeof HierarchicalNSWT;\n  }> {\n    return HierarchicalNSW;\n  }\n}"
        }
    ]
}